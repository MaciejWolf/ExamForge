import { describe, it, expect } from 'vitest';
import { configureAssessmentModule, AssessmentModule } from '../index';
import { ok } from '../../shared/result';
import { TestContentPackage } from '../../design/types/testContentPackage';
import { TemplateProvider } from '../useCases/listSessions';

describe('Start Test Instance Use Case', () => {
  it('Given valid access code and open session, when startTestInstance is called, then startedAt is updated to current time', async () => {
    const module = givenAssessmentModule();
    const accessCode = await givenOpenSessionWithTestInstance(module);

    const result = await module.startTestInstance(accessCode);

    thenTestInstanceShouldBeStarted(result, accessCode);
  });

  it('Given instance with existing startedAt, when startTestInstance is called, then TestAlreadyStarted error is returned', async () => {
    const module = givenAssessmentModule();
    const accessCode = await givenOpenSessionWithTestInstance(module);

    // Start the test instance once
    await module.startTestInstance(accessCode);

    // Try to start it again
    const result = await module.startTestInstance(accessCode);

    thenTestAlreadyStartedErrorShouldBeReturned(result, accessCode);
  });
});

// --- Test Helpers ---

const givenAssessmentModule = (): AssessmentModule => {
  let idCounter = 0;
  let accessCodeCounter = 0;

  return configureAssessmentModule({
    idGenerator: () => `test-id-${++idCounter}`,
    accessCodeGenerator: () => `TEST-${String(++accessCodeCounter).padStart(3, '0')}`,
    now: () => new Date('2024-01-01T10:00:00Z'),
    materializeTemplate: async (templateId: string) => {
      // Mock materialization - returns a dummy test content package
      const testContent: TestContentPackage = {
        id: `content-${templateId}`,
        templateId,
        sections: [],
        createdAt: new Date('2024-01-01T09:00:00Z')
      };
      return ok(testContent);
    },
    templateProvider: {
      getTemplateNames: async (templateIds: string[]) => {
        // Mock template provider - returns a map of template IDs to names
        const names = new Map<string, string>();
        templateIds.forEach(id => names.set(id, `Template ${id}`));
        return names;
      }
    } satisfies TemplateProvider
  });
};

const givenOpenSessionWithTestInstance = async (module: AssessmentModule): Promise<string> => {
  const sessionResult = await module.startSession({
    templateId: 'template-1',
    examinerId: 'examiner-1',
    timeLimitMinutes: 60,
    startTime: new Date('2024-01-01T09:00:00Z'),
    endTime: new Date('2024-01-01T11:00:00Z'),
    participantIdentifiers: ['student-1']
  });

  if (!sessionResult.ok) {
    throw new Error(`Failed to create test session: ${JSON.stringify(sessionResult.error)}`);
  }

  // The access code is generated by the startSession use case
  // Since we control the accessCodeGenerator, we know it will be 'TEST-001'
  return 'TEST-001';
};

const thenTestInstanceShouldBeStarted = (
  result: Awaited<ReturnType<AssessmentModule['startTestInstance']>>,
  accessCode: string
) => {
  expect(result.ok).toBe(true);
  if (result.ok) {
    expect(result.value.accessCode).toBe(accessCode);
    expect(result.value.startedAt).toEqual(new Date('2024-01-01T10:00:00Z'));
    expect(result.value.identifier).toBe('student-1');
  }
};

const thenTestAlreadyStartedErrorShouldBeReturned = (
  result: Awaited<ReturnType<AssessmentModule['startTestInstance']>>,
  accessCode: string
) => {
  expect(result.ok).toBe(false);
  if (!result.ok) {
    expect(result.error.type).toBe('TestAlreadyStarted');
    if (result.error.type === 'TestAlreadyStarted') {
      expect(result.error.accessCode).toBe(accessCode);
    }
  }
};
