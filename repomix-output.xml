This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: backend
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/.gitignore
backend/.npmrc
backend/package.json
backend/src/index.ts
backend/src/lib/supabase.ts
backend/src/middleware/auth.ts
backend/src/routes/questionPools.ts
backend/src/routes/questions.ts
backend/src/routes/testSessions.ts
backend/src/routes/testTemplates.ts
backend/src/services/mockData.ts
backend/src/swagger.ts
backend/supabase/.gitignore
backend/supabase/config.toml
backend/tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.npmrc">
registry=https://registry.npmjs.org/
</file>

<file path="backend/src/lib/supabase.ts">
import { createClient, SupabaseClient } from '@supabase/supabase-js';

let supabase: SupabaseClient;

export const getSupabaseClient = () => {
  if (!supabase) {
    const supabaseUrl = process.env.VITE_SUPABASE_URL;
    const supabaseAnonKey = process.env.VITE_SUPABASE_ANON_KEY;

    if (!supabaseUrl || !supabaseAnonKey) {
      throw new Error("Supabase URL and Anon Key must be provided.");
    }

    supabase = createClient(supabaseUrl, supabaseAnonKey);
  }
  return supabase;
};
</file>

<file path="backend/src/routes/testTemplates.ts">
import { Router, Response } from 'express';
import { verifyAuth, AuthRequest } from '../middleware/auth';
import * as mockDataService from '../services/mockData';

const router = Router();

/**
 * @swagger
 * /api/test-templates:
 *   get:
 *     summary: Get all test templates for the authenticated user
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of test templates
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 templates:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                       name:
 *                         type: string
 *                       examiner_id:
 *                         type: string
 *                       poolSelections:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             poolId:
 *                               type: string
 *                             questionsToDraw:
 *                               type: number
 *                       createdAt:
 *                         type: string
 *       401:
 *         description: Unauthorized
 */
router.get('/', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const templates = mockDataService.getTemplatesByExaminer(examinerId);
    res.status(200).json({ templates });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/test-templates/{id}:
 *   get:
 *     summary: Get a test template by ID
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Test template details
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Template not found
 */
router.get('/:id', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { id } = req.params;
    const template = mockDataService.getTemplateById(id, examinerId);

    if (!template) {
      return res.status(404).json({ error: 'Template not found' });
    }

    res.status(200).json(template);
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/test-templates:
 *   post:
 *     summary: Create a new test template
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - poolSelections
 *             properties:
 *               name:
 *                 type: string
 *               poolSelections:
 *                 type: array
 *                 items:
 *                   type: object
 *                   required:
 *                     - poolId
 *                     - questionsToDraw
 *                   properties:
 *                     poolId:
 *                       type: string
 *                     questionsToDraw:
 *                       type: number
 *     responses:
 *       201:
 *         description: Template created successfully
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 */
router.post('/', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { name, poolSelections } = req.body;

    if (!name || typeof name !== 'string' || !name.trim()) {
      return res.status(400).json({ error: 'Template name is required' });
    }

    if (!poolSelections || !Array.isArray(poolSelections) || poolSelections.length === 0) {
      return res.status(400).json({ error: 'At least one pool selection is required' });
    }

    try {
      const newTemplate = mockDataService.createTemplate(name, poolSelections, examinerId);
      res.status(201).json(newTemplate);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to create template';
      return res.status(400).json({ error: errorMessage });
    }
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/test-templates/{id}:
 *   put:
 *     summary: Update a test template
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - poolSelections
 *             properties:
 *               name:
 *                 type: string
 *               poolSelections:
 *                 type: array
 *                 items:
 *                   type: object
 *                   required:
 *                     - poolId
 *                     - questionsToDraw
 *                   properties:
 *                     poolId:
 *                       type: string
 *                     questionsToDraw:
 *                       type: number
 *     responses:
 *       200:
 *         description: Template updated successfully
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Template not found
 */
router.put('/:id', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { id } = req.params;
    const { name, poolSelections } = req.body;

    if (!name || typeof name !== 'string' || !name.trim()) {
      return res.status(400).json({ error: 'Template name is required' });
    }

    if (!poolSelections || !Array.isArray(poolSelections) || poolSelections.length === 0) {
      return res.status(400).json({ error: 'At least one pool selection is required' });
    }

    try {
      const updatedTemplate = mockDataService.updateTemplate(id, name, poolSelections, examinerId);

      if (!updatedTemplate) {
        return res.status(404).json({ error: 'Template not found' });
      }

      res.status(200).json(updatedTemplate);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to update template';
      return res.status(400).json({ error: errorMessage });
    }
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/test-templates/{id}:
 *   delete:
 *     summary: Delete a test template
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Template deleted successfully
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Template not found
 */
router.delete('/:id', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { id } = req.params;
    const deleted = mockDataService.deleteTemplate(id, examinerId);

    if (!deleted) {
      return res.status(404).json({ error: 'Template not found' });
    }

    res.status(200).json({ message: 'Template deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
</file>

<file path="backend/supabase/.gitignore">
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
</file>

<file path="backend/supabase/config.toml">
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "backend"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false
# Paths to self-signed certificate pair.
# cert_path = "../certs/my-cert.pem"
# key_path = "../certs/my-key.pem"

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# JWT issuer URL. If not set, defaults to the local API URL (http://127.0.0.1:<port>/auth/v1).
# jwt_issuer = ""
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

# Uncomment to customize notification email template
# [auth.email.notification.password_changed]
# enabled = true
# subject = "Your password has been changed"
# content_path = "./templates/password_changed_notification.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false
# If enabled, it will allow the user to successfully authenticate when the provider does not return an email address.
email_optional = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

# OAuth server configuration
[auth.oauth_server]
# Enable OAuth server functionality
enabled = false
# Path for OAuth consent flow UI
authorization_url_path = "/oauth/consent"
# Allow dynamic client registration
allow_dynamic_registration = false

[edge_runtime]
enabled = true
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default) — enables hot reload during local development.
# `oneshot` — fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
</file>

<file path="backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
</file>

<file path="backend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

.env
</file>

<file path="backend/src/routes/questionPools.ts">
import { Router, Response } from 'express';
import { verifyAuth, AuthRequest } from '../middleware/auth';
import * as mockDataService from '../services/mockData';
import questionsRouter from './questions';

const router = Router();

/**
 * @swagger
 * /api/question-pools:
 *   get:
 *     summary: Get all question pools for the authenticated user
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of question pools
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 pools:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                       name:
 *                         type: string
 *                       questionCount:
 *                         type: number
 *                       createdAt:
 *                         type: string
 *       401:
 *         description: Unauthorized
 */
router.get('/', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const pools = mockDataService.getPoolsByExaminer(examinerId);
    res.status(200).json({ pools });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/question-pools:
 *   post:
 *     summary: Create a new question pool
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *             properties:
 *               name:
 *                 type: string
 *     responses:
 *       201:
 *         description: Pool created successfully
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 */
router.post('/', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { name } = req.body;

    if (!name || typeof name !== 'string' || !name.trim()) {
      return res.status(400).json({ error: 'Pool name is required' });
    }

    const newPool = mockDataService.createPool(name.trim(), examinerId);
    res.status(201).json(newPool);
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/question-pools/{id}:
 *   put:
 *     summary: Update a question pool
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *             properties:
 *               name:
 *                 type: string
 *     responses:
 *       200:
 *         description: Pool updated successfully
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Pool not found
 */
router.put('/:id', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { id } = req.params;
    const { name } = req.body;

    if (!name || typeof name !== 'string' || !name.trim()) {
      return res.status(400).json({ error: 'Pool name is required' });
    }

    const updatedPool = mockDataService.updatePool(id, name.trim(), examinerId);

    if (!updatedPool) {
      return res.status(404).json({ error: 'Pool not found' });
    }

    res.status(200).json(updatedPool);
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/question-pools/{id}:
 *   delete:
 *     summary: Delete a question pool
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Pool deleted successfully
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Pool not found
 */
router.delete('/:id', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { id } = req.params;
    const deleted = mockDataService.deletePool(id, examinerId);

    if (!deleted) {
      return res.status(404).json({ error: 'Pool not found' });
    }

    res.status(200).json({ message: 'Pool deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Mount questions router as nested route
router.use('/:poolId/questions', questionsRouter);

export default router;
</file>

<file path="backend/src/routes/questions.ts">
import { Router, Response } from 'express';
import { verifyAuth, AuthRequest } from '../middleware/auth';
import * as mockDataService from '../services/mockData';

const router = Router({ mergeParams: true }); // mergeParams to access poolId from parent route

/**
 * @swagger
 * /api/question-pools/{poolId}/questions:
 *   get:
 *     summary: Get all questions for a specific question pool
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: poolId
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: List of questions
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 questions:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                       content:
 *                         type: string
 *                       answers:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             id:
 *                               type: string
 *                             text:
 *                               type: string
 *                             isCorrect:
 *                               type: boolean
 *                       createdAt:
 *                         type: string
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Pool not found
 */
router.get('/', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { poolId } = req.params;

    // Verify pool exists and belongs to examiner
    const pool = mockDataService.getPoolById(poolId, examinerId);
    if (!pool) {
      return res.status(404).json({ error: 'Pool not found' });
    }

    const questions = mockDataService.getQuestionsByPool(poolId, examinerId);
    res.status(200).json({ questions });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/question-pools/{poolId}/questions:
 *   post:
 *     summary: Create a new question in a question pool
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: poolId
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - content
 *               - answers
 *             properties:
 *               content:
 *                 type: string
 *               answers:
 *                 type: array
 *                 items:
 *                   type: object
 *                   required:
 *                     - text
 *                     - isCorrect
 *                   properties:
 *                     text:
 *                       type: string
 *                     isCorrect:
 *                       type: boolean
 *     responses:
 *       201:
 *         description: Question created successfully
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Pool not found
 */
router.post('/', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { poolId } = req.params;
    const { content, answers } = req.body;

    // Validate pool exists
    const pool = mockDataService.getPoolById(poolId, examinerId);
    if (!pool) {
      return res.status(404).json({ error: 'Pool not found' });
    }

    // Validate input
    if (!content || typeof content !== 'string' || !content.trim()) {
      return res.status(400).json({ error: 'Question content is required' });
    }

    if (!Array.isArray(answers) || answers.length < 2 || answers.length > 6) {
      return res.status(400).json({ error: 'Question must have between 2 and 6 answers' });
    }

    // Validate answers structure
    for (const answer of answers) {
      if (!answer.text || typeof answer.text !== 'string' || !answer.text.trim()) {
        return res.status(400).json({ error: 'All answers must have non-empty text' });
      }
      if (typeof answer.isCorrect !== 'boolean') {
        return res.status(400).json({ error: 'All answers must have a valid isCorrect boolean value' });
      }
    }

    // Validate exactly one correct answer
    const correctAnswers = answers.filter((a: any) => a.isCorrect).length;
    if (correctAnswers !== 1) {
      return res.status(400).json({ error: 'Question must have exactly one correct answer' });
    }

    const newQuestion = mockDataService.createQuestion(
      poolId,
      content.trim(),
      answers,
      examinerId
    );

    if (!newQuestion) {
      return res.status(404).json({ error: 'Pool not found' });
    }

    res.status(201).json(newQuestion);
  } catch (error) {
    if (error instanceof Error) {
      return res.status(400).json({ error: error.message });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/question-pools/{poolId}/questions/{questionId}:
 *   put:
 *     summary: Update a question in a question pool
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: poolId
 *         required: true
 *         schema:
 *           type: string
 *       - in: path
 *         name: questionId
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - content
 *               - answers
 *             properties:
 *               content:
 *                 type: string
 *               answers:
 *                 type: array
 *                 items:
 *                   type: object
 *                   required:
 *                     - text
 *                     - isCorrect
 *                   properties:
 *                     text:
 *                       type: string
 *                     isCorrect:
 *                       type: boolean
 *     responses:
 *       200:
 *         description: Question updated successfully
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Question or pool not found
 */
router.put('/:questionId', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { poolId, questionId } = req.params;
    const { content, answers } = req.body;

    // Validate pool exists
    const pool = mockDataService.getPoolById(poolId, examinerId);
    if (!pool) {
      return res.status(404).json({ error: 'Pool not found' });
    }

    // Validate input
    if (!content || typeof content !== 'string' || !content.trim()) {
      return res.status(400).json({ error: 'Question content is required' });
    }

    if (!Array.isArray(answers) || answers.length < 2 || answers.length > 6) {
      return res.status(400).json({ error: 'Question must have between 2 and 6 answers' });
    }

    // Validate answers structure
    for (const answer of answers) {
      if (!answer.text || typeof answer.text !== 'string' || !answer.text.trim()) {
        return res.status(400).json({ error: 'All answers must have non-empty text' });
      }
      if (typeof answer.isCorrect !== 'boolean') {
        return res.status(400).json({ error: 'All answers must have a valid isCorrect boolean value' });
      }
    }

    // Validate exactly one correct answer
    const correctAnswers = answers.filter((a: any) => a.isCorrect).length;
    if (correctAnswers !== 1) {
      return res.status(400).json({ error: 'Question must have exactly one correct answer' });
    }

    const updatedQuestion = mockDataService.updateQuestion(
      questionId,
      poolId,
      content.trim(),
      answers,
      examinerId
    );

    if (!updatedQuestion) {
      return res.status(404).json({ error: 'Question not found' });
    }

    res.status(200).json(updatedQuestion);
  } catch (error) {
    if (error instanceof Error) {
      return res.status(400).json({ error: error.message });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/question-pools/{poolId}/questions/{questionId}:
 *   delete:
 *     summary: Delete a question from a question pool
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: poolId
 *         required: true
 *         schema:
 *           type: string
 *       - in: path
 *         name: questionId
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Question deleted successfully
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Question or pool not found
 */
router.delete('/:questionId', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { poolId, questionId } = req.params;

    // Verify pool exists
    const pool = mockDataService.getPoolById(poolId, examinerId);
    if (!pool) {
      return res.status(404).json({ error: 'Pool not found' });
    }

    const deleted = mockDataService.deleteQuestion(questionId, poolId, examinerId);

    if (!deleted) {
      return res.status(404).json({ error: 'Question not found' });
    }

    res.status(200).json({ message: 'Question deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
</file>

<file path="backend/src/swagger.ts">
import swaggerJSDoc from 'swagger-jsdoc';

const swaggerOptions: swaggerJSDoc.Options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'ExamForge API',
      version: '1.0.0',
      description: 'API documentation for the ExamForge application',
    },
    servers: [
      {
        url: 'http://localhost:3000',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
  },
  apis: ['./src/index.ts'], // Path to the API docs
};

const swaggerSpec = swaggerJSDoc(swaggerOptions);

export default swaggerSpec;
</file>

<file path="backend/src/middleware/auth.ts">
import { Request, Response, NextFunction } from 'express';
import { getSupabaseClient } from '../lib/supabase';

export interface AuthRequest extends Request {
  user?: {
    id: string;
    email?: string;
  };
}

export const verifyAuth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Missing or invalid authorization header' });
    }

    const token = authHeader.substring(7);

    const { data: { user }, error } = await getSupabaseClient().auth.getUser(token);

    if (error || !user) {
      return res.status(401).json({ error: 'Invalid or expired token' });
    }

    req.user = {
      id: user.id,
      email: user.email,
    };

    next();
  } catch (error) {
    return res.status(401).json({ error: 'Authentication failed' });
  }
};
</file>

<file path="backend/src/routes/testSessions.ts">
import { Router, Response } from 'express';
import { verifyAuth, AuthRequest } from '../middleware/auth';
import * as mockDataService from '../services/mockData';

const router = Router();

/**
 * @swagger
 * /api/test-sessions:
 *   post:
 *     summary: Create a new test session
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - templateId
 *               - timeLimitMinutes
 *               - participants
 *             properties:
 *               templateId:
 *                 type: string
 *               timeLimitMinutes:
 *                 type: number
 *               participants:
 *                 type: array
 *                 items:
 *                   type: string
 *     responses:
 *       201:
 *         description: Test session created successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 session:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                     template_id:
 *                       type: string
 *                     examiner_id:
 *                       type: string
 *                     time_limit_minutes:
 *                       type: number
 *                     status:
 *                       type: string
 *                     createdAt:
 *                       type: string
 *                 participants:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                       session_id:
 *                         type: string
 *                       identifier:
 *                         type: string
 *                       access_code:
 *                         type: string
 *                       status:
 *                         type: string
 *                       createdAt:
 *                         type: string
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 */
router.post('/', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { templateId, timeLimitMinutes, participants } = req.body;

    if (!templateId || typeof templateId !== 'string' || !templateId.trim()) {
      return res.status(400).json({ error: 'Template ID is required' });
    }

    if (!timeLimitMinutes || typeof timeLimitMinutes !== 'number') {
      return res.status(400).json({ error: 'Time limit in minutes is required' });
    }

    if (!Array.isArray(participants) || participants.length === 0) {
      return res.status(400).json({ error: 'At least one participant identifier is required' });
    }

    try {
      const result = mockDataService.createTestSession(
        templateId.trim(),
        timeLimitMinutes,
        participants,
        examinerId
      );
      res.status(201).json(result);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to create test session';
      return res.status(400).json({ error: errorMessage });
    }
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/test-sessions:
 *   get:
 *     summary: Get all test sessions for the authenticated user
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: List of test sessions
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 sessions:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: string
 *                       template_id:
 *                         type: string
 *                       examiner_id:
 *                         type: string
 *                       time_limit_minutes:
 *                         type: number
 *                       status:
 *                         type: string
 *                       createdAt:
 *                         type: string
 *       401:
 *         description: Unauthorized
 */
router.get('/', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const sessions = mockDataService.getTestSessionsDetailsByExaminer(examinerId);
    res.status(200).json({ sessions });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/test-sessions/{id}/report:
 *   get:
 *     summary: Get test session report with statistics and question analysis
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Test session report
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Session not found
 */
router.get('/:id/report', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { id } = req.params;
    const session = mockDataService.getTestSessionById(id, examinerId);

    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    // Generate mock data if not already generated
    const participants = mockDataService.getParticipantsBySession(id, examinerId);
    if (participants.length > 0 && participants[0].total_score === undefined) {
      mockDataService.generateMockParticipantData(id, examinerId);
    }

    const template = mockDataService.getTemplateById(session.template_id, examinerId);
    const allParticipants = mockDataService.getParticipantsBySession(id, examinerId);
    const statistics = mockDataService.calculateSessionStatistics(id, examinerId);
    const questionAnalysis = mockDataService.calculateQuestionAnalysis(id, examinerId);

    res.status(200).json({
      session: {
        ...session,
        template_name: template?.name || 'Unknown Template',
      },
      participants: allParticipants,
      statistics,
      questionAnalysis,
    });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/test-sessions/{sessionId}/participants/{participantId}:
 *   get:
 *     summary: Get participant details with answers
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: sessionId
 *         required: true
 *         schema:
 *           type: string
 *       - in: path
 *         name: participantId
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Participant details
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Session or participant not found
 */
router.get('/:sessionId/participants/:participantId', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { sessionId, participantId } = req.params;
    const detail = mockDataService.getParticipantDetails(sessionId, participantId, examinerId);

    if (!detail) {
      return res.status(404).json({ error: 'Session or participant not found' });
    }

    res.status(200).json(detail);
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * @swagger
 * /api/test-sessions/{id}:
 *   get:
 *     summary: Get a test session by ID with participants
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Test session details with participants
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 session:
 *                   type: object
 *                 participants:
 *                   type: array
 *       401:
 *         description: Unauthorized
 *       404:
 *         description: Session not found
 */
router.get('/:id', verifyAuth, (req: AuthRequest, res: Response) => {
  try {
    const examinerId = req.user?.id;
    if (!examinerId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { id } = req.params;
    const session = mockDataService.getTestSessionById(id, examinerId);

    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const participants = mockDataService.getParticipantsBySession(id, examinerId);

    res.status(200).json({ session, participants });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
</file>

<file path="backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "ts-node src/index.ts",
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@supabase/supabase-js": "^2.81.1",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.5",
    "@types/node": "^24.10.1",
    "nodemon": "^3.1.11",
    "supabase": "^2.58.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  }
}
</file>

<file path="backend/src/index.ts">
import express, { Request, Response } from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import swaggerUi from 'swagger-ui-express';
import swaggerSpec from './swagger';
import { verifyAuth, AuthRequest } from './middleware/auth';
import questionPoolsRouter from './routes/questionPools';
import testTemplatesRouter from './routes/testTemplates';
import testSessionsRouter from './routes/testSessions';

// Load environment variables from .env file
dotenv.config();

const app = express();
const port = process.env.PORT || 3000;

// CORS middleware - allow requests from frontend
app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);
    
    // Allow localhost on any port for development
    if (origin.startsWith('http://localhost:') || origin.startsWith('http://127.0.0.1:')) {
      return callback(null, true);
    }
    
    // Allow specific frontend URL from environment
    const allowedOrigin = process.env.FRONTEND_URL;
    if (allowedOrigin && origin === allowedOrigin) {
      return callback(null, true);
    }
    
    callback(null, true); // Allow all origins in development
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));

// Middleware to parse JSON bodies. This is needed for POST/PUT requests.
app.use(express.json());

// --- Swagger UI ---
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// --- API Endpoints ---

/**
 * @swagger
 * /health:
 *   get:
 *     summary: Health check
 *     description: Responds if the app is up and running
 *     responses:
 *       200:
 *         description: App is up and running
 */
app.get('/health', (req: Request, res: Response) => {
  res.status(200).json({ status: 'API is up and running' });
});

/**
 * @swagger
 * /echo:
 *   post:
 *     summary: Echo endpoint
 *     description: Echoes the request body
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *     responses:
 *       200:
 *         description: The echoed request body
 */
app.post('/echo', (req: Request, res: Response) => {
  res.status(200).json({ received: req.body });
});

/**
 * @swagger
 * /api/auth/verify:
 *   post:
 *     summary: Verify authentication token
 *     description: Verifies a Supabase JWT token and returns user information
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Token is valid, returns user information
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 valid:
 *                   type: boolean
 *                 user:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: string
 *                     email:
 *                       type: string
 *       401:
 *         description: Invalid or missing token
 */
app.post('/api/auth/verify', verifyAuth, (req: AuthRequest, res: Response) => {
  res.status(200).json({
    valid: true,
    user: {
      id: req.user?.id,
      email: req.user?.email,
    },
  });
});

/**
 * @swagger
 * /api/auth/user:
 *   get:
 *     summary: Get authenticated user information
 *     description: Returns information about the currently authenticated user
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User information retrieved successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: string
 *                 email:
 *                   type: string
 *       401:
 *         description: Invalid or missing token
 */
app.get('/api/auth/user', verifyAuth, (req: AuthRequest, res: Response) => {
  res.status(200).json({
    id: req.user?.id,
    email: req.user?.email,
  });
});

// --- Question Pools Routes ---
app.use('/api/question-pools', questionPoolsRouter);

// --- Test Templates Routes ---
app.use('/api/test-templates', testTemplatesRouter);

// --- Test Sessions Routes ---
app.use('/api/test-sessions', testSessionsRouter);

// Start the server
app.listen(port, () => {
  console.log(`Server running on http://localhost:${port}`);
});
</file>

<file path="backend/src/services/mockData.ts">
export interface QuestionPool {
  id: string;
  name: string;
  examiner_id: string;
  questionCount: number;
  createdAt: string;
}

export interface Answer {
  id: string;
  text: string;
  isCorrect: boolean;
}

export interface Question {
  id: string;
  pool_id: string;
  content: string;
  answers: Answer[];
  createdAt: string;
}

export interface TestTemplate {
  id: string;
  name: string;
  examiner_id: string;
  poolSelections: Array<{ poolId: string; questionsToDraw: number; points: number }>;
  createdAt: string;
}

export interface TestSession {
  id: string;
  template_id: string;
  examiner_id: string;
  time_limit_minutes: number;
  status: 'active' | 'completed' | 'cancelled' | 'in_progress' | 'expired';
  createdAt: string;
}

export interface Participant {
  id: string;
  session_id: string;
  identifier: string;
  access_code: string;
  status: 'not_started' | 'in_progress' | 'completed' | 'timed_out';
  started_at?: string;
  completed_at?: string;
  time_taken_minutes?: number;
  total_score?: number;
  max_score?: number;
  createdAt: string;
}

export interface ParticipantAnswer {
  question_id: string;
  selected_answer_id: string | null;
  is_correct: boolean;
  points_earned: number;
  points_possible: number;
}

// In-memory mock data storage
let mockPools: QuestionPool[] = [];
let mockQuestions: Question[] = [];
let mockTemplates: TestTemplate[] = [];
let mockTestSessions: TestSession[] = [];
let mockParticipants: Participant[] = [];
const participantAnswers = new Map<string, ParticipantAnswer[]>(); // Map<participantId, ParticipantAnswer[]>
const participantQuestions = new Map<string, Question[]>(); // Map<participantId, Question[]> - stores selected questions for each participant
const initializedUsers = new Set<string>();
let nextId = 1;
let nextQuestionId = 1;
let nextAnswerId = 1;
let nextTemplateId = 1;
let nextSessionId = 1;
let nextParticipantId = 1;

// Access code generation - 9 characters, uppercase alphanumeric, no ambiguous chars
const generateAccessCode = (): string => {
  // Exclude ambiguous characters: 0, O, 1, I, l
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  let attempts = 0;
  const maxAttempts = 100;

  do {
    code = '';
    for (let i = 0; i < 9; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    attempts++;
  } while (mockParticipants.some((p) => p.access_code === code) && attempts < maxAttempts);

  // Check if we still have a duplicate after max attempts
  if (mockParticipants.some((p) => p.access_code === code)) {
    throw new Error('Failed to generate unique access code after multiple attempts');
  }

  return code;
};

// Initialize sample pools for a user if they don't have any
const initializeSamplePools = (examinerId: string) => {
  if (initializedUsers.has(examinerId)) {
    return;
  }

  const samplePools: QuestionPool[] = [
    {
      id: String(nextId++),
      name: 'Mathematics Basic',
      examiner_id: examinerId,
      questionCount: 0,
      createdAt: new Date('2024-01-15').toISOString(),
    },
    {
      id: String(nextId++),
      name: 'Physics Advanced',
      examiner_id: examinerId,
      questionCount: 0,
      createdAt: new Date('2024-01-20').toISOString(),
    },
    {
      id: String(nextId++),
      name: 'Chemistry Foundations',
      examiner_id: examinerId,
      questionCount: 0,
      createdAt: new Date('2024-02-01').toISOString(),
    },
    {
      id: String(nextId++),
      name: 'Computer Science Fundamentals',
      examiner_id: examinerId,
      questionCount: 0,
      createdAt: new Date('2024-02-10').toISOString(),
    },
    {
      id: String(nextId++),
      name: 'History World War II',
      examiner_id: examinerId,
      questionCount: 0,
      createdAt: new Date('2024-02-15').toISOString(),
    },
    {
      id: String(nextId++),
      name: 'Biology Cell Structure',
      examiner_id: examinerId,
      questionCount: 0,
      createdAt: new Date('2024-02-20').toISOString(),
    },
  ];

  mockPools.push(...samplePools);
  initializedUsers.add(examinerId);

  // Initialize sample questions for all pools
  const mathPoolId = samplePools[0].id;
  const physicsPoolId = samplePools[1].id;
  const chemistryPoolId = samplePools[2].id;
  const csPoolId = samplePools[3].id;
  const historyPoolId = samplePools[4].id;
  const biologyPoolId = samplePools[5].id;

  const sampleQuestions: Question[] = [
    // Mathematics Basic questions
    {
      id: String(nextQuestionId++),
      pool_id: mathPoolId,
      content: 'What is 2+2?',
      answers: [
        { id: String(nextAnswerId++), text: '3', isCorrect: false },
        { id: String(nextAnswerId++), text: '4', isCorrect: true },
        { id: String(nextAnswerId++), text: '5', isCorrect: false },
        { id: String(nextAnswerId++), text: '6', isCorrect: false },
      ],
      createdAt: new Date('2024-01-15').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: mathPoolId,
      content: 'Solve: 3x = 15',
      answers: [
        { id: String(nextAnswerId++), text: '3', isCorrect: false },
        { id: String(nextAnswerId++), text: '5', isCorrect: true },
        { id: String(nextAnswerId++), text: '12', isCorrect: false },
      ],
      createdAt: new Date('2024-01-15').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: mathPoolId,
      content: 'What is the value of π (pi)?',
      answers: [
        { id: String(nextAnswerId++), text: '3.14', isCorrect: true },
        { id: String(nextAnswerId++), text: '2.71', isCorrect: false },
        { id: String(nextAnswerId++), text: '1.41', isCorrect: false },
        { id: String(nextAnswerId++), text: '4.13', isCorrect: false },
      ],
      createdAt: new Date('2024-01-16').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: mathPoolId,
      content: 'What is the square root of 64?',
      answers: [
        { id: String(nextAnswerId++), text: '6', isCorrect: false },
        { id: String(nextAnswerId++), text: '7', isCorrect: false },
        { id: String(nextAnswerId++), text: '8', isCorrect: true },
        { id: String(nextAnswerId++), text: '9', isCorrect: false },
      ],
      createdAt: new Date('2024-01-17').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: mathPoolId,
      content: 'Calculate: 15 × 4',
      answers: [
        { id: String(nextAnswerId++), text: '50', isCorrect: false },
        { id: String(nextAnswerId++), text: '60', isCorrect: true },
        { id: String(nextAnswerId++), text: '70', isCorrect: false },
        { id: String(nextAnswerId++), text: '80', isCorrect: false },
      ],
      createdAt: new Date('2024-01-18').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: mathPoolId,
      content: 'What is the area of a circle with radius 5? (Use π = 3.14)',
      answers: [
        { id: String(nextAnswerId++), text: '31.4', isCorrect: false },
        { id: String(nextAnswerId++), text: '78.5', isCorrect: true },
        { id: String(nextAnswerId++), text: '15.7', isCorrect: false },
        { id: String(nextAnswerId++), text: '25', isCorrect: false },
      ],
      createdAt: new Date('2024-01-19').toISOString(),
    },
    // Physics Advanced questions
    {
      id: String(nextQuestionId++),
      pool_id: physicsPoolId,
      content: 'What is the speed of light in vacuum?',
      answers: [
        { id: String(nextAnswerId++), text: '3 × 10^8 m/s', isCorrect: true },
        { id: String(nextAnswerId++), text: '3 × 10^6 m/s', isCorrect: false },
        { id: String(nextAnswerId++), text: '3 × 10^10 m/s', isCorrect: false },
        { id: String(nextAnswerId++), text: '3 × 10^5 m/s', isCorrect: false },
      ],
      createdAt: new Date('2024-01-20').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: physicsPoolId,
      content: 'What is Newton\'s second law of motion?',
      answers: [
        { id: String(nextAnswerId++), text: 'F = ma', isCorrect: true },
        { id: String(nextAnswerId++), text: 'E = mc²', isCorrect: false },
        { id: String(nextAnswerId++), text: 'PV = nRT', isCorrect: false },
        { id: String(nextAnswerId++), text: 'V = IR', isCorrect: false },
      ],
      createdAt: new Date('2024-01-21').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: physicsPoolId,
      content: 'What is the unit of electric current?',
      answers: [
        { id: String(nextAnswerId++), text: 'Volt', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Ampere', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Ohm', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Watt', isCorrect: false },
      ],
      createdAt: new Date('2024-01-22').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: physicsPoolId,
      content: 'What is the formula for kinetic energy?',
      answers: [
        { id: String(nextAnswerId++), text: 'KE = ½mv²', isCorrect: true },
        { id: String(nextAnswerId++), text: 'KE = mgh', isCorrect: false },
        { id: String(nextAnswerId++), text: 'KE = mv', isCorrect: false },
        { id: String(nextAnswerId++), text: 'KE = ½mv', isCorrect: false },
      ],
      createdAt: new Date('2024-01-23').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: physicsPoolId,
      content: 'What is the acceleration due to gravity on Earth?',
      answers: [
        { id: String(nextAnswerId++), text: '9.8 m/s²', isCorrect: true },
        { id: String(nextAnswerId++), text: '10 m/s²', isCorrect: false },
        { id: String(nextAnswerId++), text: '8.9 m/s²', isCorrect: false },
        { id: String(nextAnswerId++), text: '11 m/s²', isCorrect: false },
      ],
      createdAt: new Date('2024-01-24').toISOString(),
    },
    // Chemistry Foundations questions
    {
      id: String(nextQuestionId++),
      pool_id: chemistryPoolId,
      content: 'What is the chemical symbol for water?',
      answers: [
        { id: String(nextAnswerId++), text: 'H2O', isCorrect: true },
        { id: String(nextAnswerId++), text: 'CO2', isCorrect: false },
        { id: String(nextAnswerId++), text: 'NaCl', isCorrect: false },
        { id: String(nextAnswerId++), text: 'O2', isCorrect: false },
      ],
      createdAt: new Date('2024-02-01').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: chemistryPoolId,
      content: 'What is the atomic number of carbon?',
      answers: [
        { id: String(nextAnswerId++), text: '6', isCorrect: true },
        { id: String(nextAnswerId++), text: '12', isCorrect: false },
        { id: String(nextAnswerId++), text: '14', isCorrect: false },
        { id: String(nextAnswerId++), text: '8', isCorrect: false },
      ],
      createdAt: new Date('2024-02-02').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: chemistryPoolId,
      content: 'What is the pH of a neutral solution?',
      answers: [
        { id: String(nextAnswerId++), text: '5', isCorrect: false },
        { id: String(nextAnswerId++), text: '7', isCorrect: true },
        { id: String(nextAnswerId++), text: '9', isCorrect: false },
        { id: String(nextAnswerId++), text: '14', isCorrect: false },
      ],
      createdAt: new Date('2024-02-03').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: chemistryPoolId,
      content: 'What is the most abundant gas in Earth\'s atmosphere?',
      answers: [
        { id: String(nextAnswerId++), text: 'Oxygen', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Nitrogen', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Carbon dioxide', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Argon', isCorrect: false },
      ],
      createdAt: new Date('2024-02-04').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: chemistryPoolId,
      content: 'What type of bond is formed when electrons are shared between atoms?',
      answers: [
        { id: String(nextAnswerId++), text: 'Ionic bond', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Covalent bond', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Hydrogen bond', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Metallic bond', isCorrect: false },
      ],
      createdAt: new Date('2024-02-05').toISOString(),
    },
    // Computer Science Fundamentals questions
    {
      id: String(nextQuestionId++),
      pool_id: csPoolId,
      content: 'What does HTML stand for?',
      answers: [
        { id: String(nextAnswerId++), text: 'HyperText Markup Language', isCorrect: true },
        { id: String(nextAnswerId++), text: 'High-Level Text Markup Language', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Hyperlink and Text Markup Language', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Home Tool Markup Language', isCorrect: false },
      ],
      createdAt: new Date('2024-02-10').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: csPoolId,
      content: 'What is the time complexity of binary search?',
      answers: [
        { id: String(nextAnswerId++), text: 'O(n)', isCorrect: false },
        { id: String(nextAnswerId++), text: 'O(log n)', isCorrect: true },
        { id: String(nextAnswerId++), text: 'O(n²)', isCorrect: false },
        { id: String(nextAnswerId++), text: 'O(1)', isCorrect: false },
      ],
      createdAt: new Date('2024-02-11').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: csPoolId,
      content: 'What is a variable that stores a memory address called?',
      answers: [
        { id: String(nextAnswerId++), text: 'Array', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Pointer', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Reference', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Index', isCorrect: false },
      ],
      createdAt: new Date('2024-02-12').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: csPoolId,
      content: 'What does API stand for?',
      answers: [
        { id: String(nextAnswerId++), text: 'Application Programming Interface', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Automated Program Integration', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Advanced Programming Interface', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Application Process Integration', isCorrect: false },
      ],
      createdAt: new Date('2024-02-13').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: csPoolId,
      content: 'Which data structure follows LIFO (Last In First Out) principle?',
      answers: [
        { id: String(nextAnswerId++), text: 'Queue', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Stack', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Array', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Linked List', isCorrect: false },
      ],
      createdAt: new Date('2024-02-14').toISOString(),
    },
    // History World War II questions
    {
      id: String(nextQuestionId++),
      pool_id: historyPoolId,
      content: 'In which year did World War II end?',
      answers: [
        { id: String(nextAnswerId++), text: '1944', isCorrect: false },
        { id: String(nextAnswerId++), text: '1945', isCorrect: true },
        { id: String(nextAnswerId++), text: '1946', isCorrect: false },
        { id: String(nextAnswerId++), text: '1947', isCorrect: false },
      ],
      createdAt: new Date('2024-02-15').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: historyPoolId,
      content: 'Which event is considered the start of World War II in Europe?',
      answers: [
        { id: String(nextAnswerId++), text: 'Invasion of Poland', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Attack on Pearl Harbor', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Battle of Britain', isCorrect: false },
        { id: String(nextAnswerId++), text: 'D-Day', isCorrect: false },
      ],
      createdAt: new Date('2024-02-16').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: historyPoolId,
      content: 'Who was the leader of Nazi Germany during World War II?',
      answers: [
        { id: String(nextAnswerId++), text: 'Benito Mussolini', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Adolf Hitler', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Joseph Stalin', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Winston Churchill', isCorrect: false },
      ],
      createdAt: new Date('2024-02-17').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: historyPoolId,
      content: 'Which battle is considered the turning point of World War II in the Pacific?',
      answers: [
        { id: String(nextAnswerId++), text: 'Battle of Midway', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Battle of Guadalcanal', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Battle of Iwo Jima', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Battle of Okinawa', isCorrect: false },
      ],
      createdAt: new Date('2024-02-18').toISOString(),
    },
    // Biology Cell Structure questions
    {
      id: String(nextQuestionId++),
      pool_id: biologyPoolId,
      content: 'What is the powerhouse of the cell?',
      answers: [
        { id: String(nextAnswerId++), text: 'Nucleus', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Mitochondria', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Ribosome', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Golgi apparatus', isCorrect: false },
      ],
      createdAt: new Date('2024-02-20').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: biologyPoolId,
      content: 'Which organelle contains the cell\'s genetic material?',
      answers: [
        { id: String(nextAnswerId++), text: 'Mitochondria', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Nucleus', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Endoplasmic reticulum', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Lysosome', isCorrect: false },
      ],
      createdAt: new Date('2024-02-21').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: biologyPoolId,
      content: 'What is the function of ribosomes?',
      answers: [
        { id: String(nextAnswerId++), text: 'Energy production', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Protein synthesis', isCorrect: true },
        { id: String(nextAnswerId++), text: 'DNA replication', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Waste removal', isCorrect: false },
      ],
      createdAt: new Date('2024-02-22').toISOString(),
    },
    {
      id: String(nextQuestionId++),
      pool_id: biologyPoolId,
      content: 'Which type of cell lacks a nucleus?',
      answers: [
        { id: String(nextAnswerId++), text: 'Eukaryotic cell', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Prokaryotic cell', isCorrect: true },
        { id: String(nextAnswerId++), text: 'Plant cell', isCorrect: false },
        { id: String(nextAnswerId++), text: 'Animal cell', isCorrect: false },
      ],
      createdAt: new Date('2024-02-23').toISOString(),
    },
  ];

  mockQuestions.push(...sampleQuestions);
  
  // Update question counts for all pools
  samplePools[0].questionCount = sampleQuestions.filter(q => q.pool_id === mathPoolId).length;
  samplePools[1].questionCount = sampleQuestions.filter(q => q.pool_id === physicsPoolId).length;
  samplePools[2].questionCount = sampleQuestions.filter(q => q.pool_id === chemistryPoolId).length;
  samplePools[3].questionCount = sampleQuestions.filter(q => q.pool_id === csPoolId).length;
  samplePools[4].questionCount = sampleQuestions.filter(q => q.pool_id === historyPoolId).length;
  samplePools[5].questionCount = sampleQuestions.filter(q => q.pool_id === biologyPoolId).length;

  // Initialize sample test templates
  const sampleTemplates: TestTemplate[] = [
    {
      id: String(nextTemplateId++),
      name: 'Math & Physics Combined Test',
      examiner_id: examinerId,
      poolSelections: [
        { poolId: mathPoolId, questionsToDraw: 3, points: 10 },
        { poolId: physicsPoolId, questionsToDraw: 2, points: 8 },
      ],
      createdAt: new Date('2024-02-25').toISOString(),
    },
    {
      id: String(nextTemplateId++),
      name: 'Science Comprehensive Exam',
      examiner_id: examinerId,
      poolSelections: [
        { poolId: physicsPoolId, questionsToDraw: 3, points: 12 },
        { poolId: chemistryPoolId, questionsToDraw: 3, points: 10 },
        { poolId: biologyPoolId, questionsToDraw: 2, points: 6 },
      ],
      createdAt: new Date('2024-02-26').toISOString(),
    },
    {
      id: String(nextTemplateId++),
      name: 'Computer Science Basics',
      examiner_id: examinerId,
      poolSelections: [
        { poolId: csPoolId, questionsToDraw: 4, points: 14 },
      ],
      createdAt: new Date('2024-02-27').toISOString(),
    },
    {
      id: String(nextTemplateId++),
      name: 'General Knowledge Test',
      examiner_id: examinerId,
      poolSelections: [
        { poolId: mathPoolId, questionsToDraw: 2, points: 6 },
        { poolId: historyPoolId, questionsToDraw: 2, points: 8 },
        { poolId: csPoolId, questionsToDraw: 2, points: 6 },
      ],
      createdAt: new Date('2024-02-28').toISOString(),
    },
  ];

  mockTemplates.push(...sampleTemplates);

  // Initialize sample test sessions
  const sampleSessions: TestSession[] = [
    {
      id: String(nextSessionId++),
      template_id: sampleTemplates[0].id, // Math & Physics Combined Test
      examiner_id: examinerId,
      time_limit_minutes: 60,
      status: 'completed',
      createdAt: new Date('2025-11-15').toISOString(),
    },
    {
      id: String(nextSessionId++),
      template_id: sampleTemplates[1].id, // Science Comprehensive Exam
      examiner_id: examinerId,
      time_limit_minutes: 45,
      status: 'active',
      createdAt: new Date('2025-11-14').toISOString(),
    },
    {
      id: String(nextSessionId++),
      template_id: sampleTemplates[2].id, // Computer Science Basics
      examiner_id: examinerId,
      time_limit_minutes: 90,
      status: 'completed',
      createdAt: new Date('2025-11-13').toISOString(),
    },
    {
      id: String(nextSessionId++),
      template_id: sampleTemplates[3].id, // General Knowledge Test
      examiner_id: examinerId,
      time_limit_minutes: 30,
      status: 'active',
      createdAt: new Date('2025-11-12').toISOString(),
    },
  ];

  mockTestSessions.push(...sampleSessions);

  // Initialize sample participants for the test sessions
  const sampleParticipants: Participant[] = [
    // Participants for first session (completed)
    ...Array.from({ length: 25 }, (_, i) => ({
      id: String(nextParticipantId++),
      session_id: sampleSessions[0].id,
      identifier: `Student ${i + 1}`,
      access_code: generateAccessCode(),
      status: 'completed' as const,
      score: Math.floor(Math.random() * 100),
      createdAt: new Date('2025-11-15').toISOString(),
    })),
    // Participants for second session (active)
    ...Array.from({ length: 15 }, (_, i) => ({
      id: String(nextParticipantId++),
      session_id: sampleSessions[1].id,
      identifier: `Participant ${i + 1}`,
      access_code: generateAccessCode(),
      status: (i < 10 ? 'completed' : 'not_started') as 'not_started' | 'completed',
      score: i < 10 ? Math.floor(Math.random() * 100) : undefined,
      createdAt: new Date('2025-11-14').toISOString(),
    })),
    // Participants for third session (completed)
    ...Array.from({ length: 30 }, (_, i) => ({
      id: String(nextParticipantId++),
      session_id: sampleSessions[2].id,
      identifier: `CS Student ${i + 1}`,
      access_code: generateAccessCode(),
      status: 'completed' as const,
      score: Math.floor(Math.random() * 100),
      createdAt: new Date('2025-11-13').toISOString(),
    })),
    // Participants for fourth session (active)
    ...Array.from({ length: 10 }, (_, i) => ({
      id: String(nextParticipantId++),
      session_id: sampleSessions[3].id,
      identifier: `GK Participant ${i + 1}`,
      access_code: generateAccessCode(),
      status: 'not_started' as const,
      createdAt: new Date('2025-11-12').toISOString(),
    })),
  ];

  mockParticipants.push(...sampleParticipants);
};

export const getPoolsByExaminer = (examinerId: string): QuestionPool[] => {
  // Initialize sample pools for new users
  if (!initializedUsers.has(examinerId)) {
    initializeSamplePools(examinerId);
  }
  return mockPools.filter((pool) => pool.examiner_id === examinerId);
};

export const getPoolById = (poolId: string, examinerId: string): QuestionPool | undefined => {
  return mockPools.find((pool) => pool.id === poolId && pool.examiner_id === examinerId);
};

export const createPool = (name: string, examinerId: string): QuestionPool => {
  const newPool: QuestionPool = {
    id: String(nextId++),
    name,
    examiner_id: examinerId,
    questionCount: 0,
    createdAt: new Date().toISOString(),
  };
  mockPools.push(newPool);
  return newPool;
};

export const updatePool = (poolId: string, name: string, examinerId: string): QuestionPool | null => {
  const pool = getPoolById(poolId, examinerId);
  if (!pool) return null;
  
  pool.name = name;
  return pool;
};

export const deletePool = (poolId: string, examinerId: string): boolean => {
  const index = mockPools.findIndex((pool) => pool.id === poolId && pool.examiner_id === examinerId);
  if (index === -1) return false;
  
  // Delete all questions in this pool
  mockQuestions = mockQuestions.filter((q) => q.pool_id !== poolId);
  
  mockPools.splice(index, 1);
  return true;
};

// Helper function to update question count for a pool
const updatePoolQuestionCount = (poolId: string) => {
  const pool = mockPools.find((p) => p.id === poolId);
  if (pool) {
    pool.questionCount = mockQuestions.filter((q) => q.pool_id === poolId).length;
  }
};

// Question CRUD operations
export const getQuestionsByPool = (poolId: string, examinerId: string): Question[] => {
  // Verify pool belongs to examiner
  const pool = getPoolById(poolId, examinerId);
  if (!pool) return [];
  
  return mockQuestions.filter((q) => q.pool_id === poolId);
};

export const getQuestionById = (questionId: string, poolId: string, examinerId: string): Question | undefined => {
  // Verify pool belongs to examiner
  const pool = getPoolById(poolId, examinerId);
  if (!pool) return undefined;
  
  return mockQuestions.find((q) => q.id === questionId && q.pool_id === poolId);
};

export const createQuestion = (
  poolId: string,
  content: string,
  answers: Omit<Answer, 'id'>[],
  examinerId: string
): Question | null => {
  // Verify pool belongs to examiner
  const pool = getPoolById(poolId, examinerId);
  if (!pool) return null;

  // Validate answers
  if (answers.length < 2 || answers.length > 6) {
    throw new Error('Question must have between 2 and 6 answers');
  }

  const correctAnswers = answers.filter((a) => a.isCorrect).length;
  if (correctAnswers !== 1) {
    throw new Error('Question must have exactly one correct answer');
  }

  // Validate all answer texts are non-empty
  if (answers.some((a) => !a.text || !a.text.trim())) {
    throw new Error('All answers must have non-empty text');
  }

  const newQuestion: Question = {
    id: String(nextQuestionId++),
    pool_id: poolId,
    content: content.trim(),
    answers: answers.map((a) => ({
      id: String(nextAnswerId++),
      text: a.text.trim(),
      isCorrect: a.isCorrect,
    })),
    createdAt: new Date().toISOString(),
  };

  mockQuestions.push(newQuestion);
  updatePoolQuestionCount(poolId);
  
  return newQuestion;
};

export const updateQuestion = (
  questionId: string,
  poolId: string,
  content: string,
  answers: Omit<Answer, 'id'>[],
  examinerId: string
): Question | null => {
  // Verify pool belongs to examiner
  const pool = getPoolById(poolId, examinerId);
  if (!pool) return null;

  const question = getQuestionById(questionId, poolId, examinerId);
  if (!question) return null;

  // Validate answers
  if (answers.length < 2 || answers.length > 6) {
    throw new Error('Question must have between 2 and 6 answers');
  }

  const correctAnswers = answers.filter((a) => a.isCorrect).length;
  if (correctAnswers !== 1) {
    throw new Error('Question must have exactly one correct answer');
  }

  // Validate all answer texts are non-empty
  if (answers.some((a) => !a.text || !a.text.trim())) {
    throw new Error('All answers must have non-empty text');
  }

  // Update question
  question.content = content.trim();
  question.answers = answers.map((a) => ({
    id: String(nextAnswerId++),
    text: a.text.trim(),
    isCorrect: a.isCorrect,
  }));

  return question;
};

export const deleteQuestion = (questionId: string, poolId: string, examinerId: string): boolean => {
  // Verify pool belongs to examiner
  const pool = getPoolById(poolId, examinerId);
  if (!pool) return false;

  const index = mockQuestions.findIndex((q) => q.id === questionId && q.pool_id === poolId);
  if (index === -1) return false;

  mockQuestions.splice(index, 1);
  updatePoolQuestionCount(poolId);
  
  return true;
};

// Test Template CRUD operations
export const getTemplatesByExaminer = (examinerId: string): TestTemplate[] => {
  return mockTemplates.filter((template) => template.examiner_id === examinerId);
};

export const getTemplateById = (templateId: string, examinerId: string): TestTemplate | undefined => {
  return mockTemplates.find(
    (template) => template.id === templateId && template.examiner_id === examinerId
  );
};

export const createTemplate = (
  name: string,
  poolSelections: Array<{ poolId: string; questionsToDraw: number; points: number }>,
  examinerId: string
): TestTemplate => {
  // Validate name uniqueness within examiner's templates
  const existingTemplates = getTemplatesByExaminer(examinerId);
  if (existingTemplates.some((t) => t.name.toLowerCase() === name.trim().toLowerCase())) {
    throw new Error('Template name must be unique');
  }

  // Validate at least one pool selection
  if (!poolSelections || poolSelections.length === 0) {
    throw new Error('At least one question pool must be selected');
  }

  // Validate each pool selection
  for (const selection of poolSelections) {
    // Validate questionsToDraw is positive integer
    if (!Number.isInteger(selection.questionsToDraw) || selection.questionsToDraw <= 0) {
      throw new Error('Questions to draw must be a positive integer');
    }

    // Validate points is positive number
    if (typeof selection.points !== 'number' || selection.points <= 0) {
      throw new Error('Points must be a positive number');
    }

    // Verify pool belongs to examiner
    const pool = getPoolById(selection.poolId, examinerId);
    if (!pool) {
      throw new Error(`Pool with id ${selection.poolId} not found or does not belong to examiner`);
    }

    // Validate questionsToDraw doesn't exceed available questions
    const availableQuestions = mockQuestions.filter((q) => q.pool_id === selection.poolId).length;
    if (selection.questionsToDraw > availableQuestions) {
      throw new Error(
        `Cannot draw ${selection.questionsToDraw} questions from pool "${pool.name}" (only ${availableQuestions} available)`
      );
    }
  }

  const newTemplate: TestTemplate = {
    id: String(nextTemplateId++),
    name: name.trim(),
    examiner_id: examinerId,
    poolSelections,
    createdAt: new Date().toISOString(),
  };

  mockTemplates.push(newTemplate);
  return newTemplate;
};

export const updateTemplate = (
  templateId: string,
  name: string,
  poolSelections: Array<{ poolId: string; questionsToDraw: number; points: number }>,
  examinerId: string
): TestTemplate | null => {
  const template = getTemplateById(templateId, examinerId);
  if (!template) return null;

  // Validate name uniqueness (excluding current template)
  const existingTemplates = getTemplatesByExaminer(examinerId);
  if (
    existingTemplates.some(
      (t) => t.id !== templateId && t.name.toLowerCase() === name.trim().toLowerCase()
    )
  ) {
    throw new Error('Template name must be unique');
  }

  // Validate at least one pool selection
  if (!poolSelections || poolSelections.length === 0) {
    throw new Error('At least one question pool must be selected');
  }

  // Validate each pool selection
  for (const selection of poolSelections) {
    // Validate questionsToDraw is positive integer
    if (!Number.isInteger(selection.questionsToDraw) || selection.questionsToDraw <= 0) {
      throw new Error('Questions to draw must be a positive integer');
    }

    // Validate points is positive number
    if (typeof selection.points !== 'number' || selection.points <= 0) {
      throw new Error('Points must be a positive number');
    }

    // Verify pool belongs to examiner
    const pool = getPoolById(selection.poolId, examinerId);
    if (!pool) {
      throw new Error(`Pool with id ${selection.poolId} not found or does not belong to examiner`);
    }

    // Validate questionsToDraw doesn't exceed available questions
    const availableQuestions = mockQuestions.filter((q) => q.pool_id === selection.poolId).length;
    if (selection.questionsToDraw > availableQuestions) {
      throw new Error(
        `Cannot draw ${selection.questionsToDraw} questions from pool "${pool.name}" (only ${availableQuestions} available)`
      );
    }
  }

  // Update template
  template.name = name.trim();
  template.poolSelections = poolSelections;
  return template;
};

export const deleteTemplate = (templateId: string, examinerId: string): boolean => {
  const index = mockTemplates.findIndex(
    (template) => template.id === templateId && template.examiner_id === examinerId
  );
  if (index === -1) return false;

  mockTemplates.splice(index, 1);
  return true;
};

// Test Session CRUD operations
export const createTestSession = (
  templateId: string,
  timeLimitMinutes: number,
  participantIdentifiers: string[],
  examinerId: string
): { session: TestSession; participants: Participant[] } => {
  // Verify template exists and belongs to examiner
  const template = getTemplateById(templateId, examinerId);
  if (!template) {
    throw new Error('Template not found or does not belong to examiner');
  }

  // Validate time limit
  if (!Number.isInteger(timeLimitMinutes) || timeLimitMinutes < 1 || timeLimitMinutes > 480) {
    throw new Error('Time limit must be between 1 and 480 minutes');
  }

  // Validate participants
  const validIdentifiers = participantIdentifiers
    .map((id) => id.trim())
    .filter((id) => id.length > 0);

  if (validIdentifiers.length === 0) {
    throw new Error('At least one participant identifier is required');
  }

  // Create test session
  const session: TestSession = {
    id: String(nextSessionId++),
    template_id: templateId,
    examiner_id: examinerId,
    time_limit_minutes: timeLimitMinutes,
    status: 'active',
    createdAt: new Date().toISOString(),
  };

  mockTestSessions.push(session);

  // Create participants with unique access codes
  const participants: Participant[] = validIdentifiers.map((identifier) => {
    const participant: Participant = {
      id: String(nextParticipantId++),
      session_id: session.id,
      identifier,
      access_code: generateAccessCode(),
      status: 'not_started',
      createdAt: new Date().toISOString(),
    };
    mockParticipants.push(participant);
    return participant;
  });

  return { session, participants };
};

export const getTestSessionsByExaminer = (examinerId: string): TestSession[] => {
  return mockTestSessions.filter((session) => session.examiner_id === examinerId);
};

export const getTestSessionById = (sessionId: string, examinerId: string): TestSession | undefined => {
  return mockTestSessions.find(
    (session) => session.id === sessionId && session.examiner_id === examinerId
  );
};

export const getParticipantsBySession = (sessionId: string, examinerId: string): Participant[] => {
  // Verify session belongs to examiner
  const session = getTestSessionById(sessionId, examinerId);
  if (!session) {
    return [];
  }

  return mockParticipants.filter((participant) => participant.session_id === sessionId);
};

export interface TestSessionDetail {
  id: string;
  template_id: string;
  template_name: string;
  examiner_id: string;
  time_limit_minutes: number;
  status: 'active' | 'completed' | 'cancelled' | 'in_progress' | 'expired';
  createdAt: string;
  participant_count: number;
}

export const getTestSessionsDetailsByExaminer = (examinerId: string): TestSessionDetail[] => {
  const sessions = getTestSessionsByExaminer(examinerId);
  
  return sessions.map((session) => {
    const template = getTemplateById(session.template_id, examinerId);
    const participants = mockParticipants.filter((p) => p.session_id === session.id);
    
    return {
      id: session.id,
      template_id: session.template_id,
      template_name: template?.name || 'Unknown Template',
      examiner_id: session.examiner_id,
      time_limit_minutes: session.time_limit_minutes,
      status: session.status,
      createdAt: session.createdAt,
      participant_count: participants.length,
    };
  });
};

// Helper function to get questions for a participant based on their session's template
const getParticipantQuestions = (participantId: string, sessionId: string, examinerId: string): Question[] => {
  // Return cached questions if available
  if (participantQuestions.has(participantId)) {
    return participantQuestions.get(participantId)!;
  }

  const session = getTestSessionById(sessionId, examinerId);
  if (!session) return [];

  const template = getTemplateById(session.template_id, examinerId);
  if (!template) return [];

  const selectedQuestions: Question[] = [];
  
  // Use participant ID as seed for deterministic random selection per participant
  let seed = parseInt(participantId.replace(/\D/g, '')) || 0;
  const seededRandom = () => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };

  for (const poolSelection of template.poolSelections) {
    const poolQuestions = mockQuestions.filter((q) => q.pool_id === poolSelection.poolId);
    // Deterministically shuffle questions from the pool
    const shuffled = [...poolQuestions].sort(() => seededRandom() - 0.5);
    const selected = shuffled.slice(0, poolSelection.questionsToDraw);
    selectedQuestions.push(...selected);
  }

  // Cache the selected questions for this participant
  participantQuestions.set(participantId, selectedQuestions);
  return selectedQuestions;
};

// Generate mock participant data for a session
export const generateMockParticipantData = (sessionId: string, examinerId: string): void => {
  const session = getTestSessionById(sessionId, examinerId);
  if (!session) return;

  const template = getTemplateById(session.template_id, examinerId);
  if (!template) return;

  // Calculate max score from template pool selections (same for all participants)
  const maxScore = template.poolSelections.reduce((sum, ps) => sum + ps.points, 0);

  const participants = getParticipantsBySession(sessionId, examinerId);

  // Update participants with mock data
  participants.forEach((participant, index) => {
    // Get unique questions for this participant
    const questions = getParticipantQuestions(participant.id, sessionId, examinerId);
    
    // Calculate points per question for each pool selection
    const questionPointsMap = new Map<string, number>();
    let questionIndex = 0;
    for (const poolSelection of template.poolSelections) {
      const pointsPerQuestion = Math.round(poolSelection.points / poolSelection.questionsToDraw);
      for (let i = 0; i < poolSelection.questionsToDraw; i++) {
        if (questionIndex < questions.length) {
          questionPointsMap.set(questions[questionIndex].id, pointsPerQuestion);
          questionIndex++;
        }
      }
    }

    const statusRoll = Math.random();
    let status: Participant['status'] = 'not_started';
    let startedAt: string | undefined;
    let completedAt: string | undefined;
    let timeTaken: number | undefined;
    let totalScore: number | undefined;

    if (statusRoll < 0.7) {
      // 70% completed
      status = 'completed';
      startedAt = new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString();
      const sessionStart = new Date(startedAt);
      timeTaken = Math.floor(Math.random() * session.time_limit_minutes * 0.8 + session.time_limit_minutes * 0.2);
      completedAt = new Date(sessionStart.getTime() + timeTaken * 60 * 1000).toISOString();
      totalScore = Math.floor(Math.random() * maxScore * 0.4 + maxScore * 0.6); // 60-100% range
    } else if (statusRoll < 0.85) {
      // 15% in progress
      status = 'in_progress';
      startedAt = new Date(Date.now() - Math.random() * 2 * 60 * 60 * 1000).toISOString();
      const sessionStart = new Date(startedAt);
      timeTaken = Math.floor((Date.now() - sessionStart.getTime()) / (60 * 1000));
      totalScore = Math.floor(Math.random() * maxScore * 0.5); // Current score 0-50%
    } else {
      // 15% not started
      status = 'not_started';
    }

    participant.status = status;
    participant.started_at = startedAt;
    participant.completed_at = completedAt;
    participant.time_taken_minutes = timeTaken;
    participant.total_score = totalScore;
    participant.max_score = maxScore;

    // Generate answers for completed and in-progress participants
    if (status === 'completed' || status === 'in_progress') {
      const answers: ParticipantAnswer[] = questions.map((question, qIndex) => {
        const pointsPerQuestion = questionPointsMap.get(question.id) || 0;
        const isCorrect = status === 'completed' 
          ? (qIndex < questions.length * (totalScore! / maxScore) + Math.random() * 0.2 - 0.1)
          : Math.random() < 0.5; // Random for in-progress
        
        const correctAnswer = question.answers.find((a) => a.isCorrect);
        const selectedAnswer = isCorrect 
          ? correctAnswer 
          : question.answers[Math.floor(Math.random() * question.answers.length)];

        return {
          question_id: question.id,
          selected_answer_id: selectedAnswer?.id || null,
          is_correct: isCorrect,
          points_earned: isCorrect ? pointsPerQuestion : 0,
          points_possible: pointsPerQuestion,
        };
      });

      participantAnswers.set(participant.id, answers);
    }
  });
};

// Calculate session statistics
export interface SessionStatistics {
  average_score: number;
  highest_score: number;
  lowest_score: number;
  completion_rate: number;
  completed_count: number;
  in_progress_count: number;
  not_started_count: number;
  total_participants: number;
}

export const calculateSessionStatistics = (sessionId: string, examinerId: string): SessionStatistics => {
  const participants = getParticipantsBySession(sessionId, examinerId);
  const completed = participants.filter((p) => p.status === 'completed');
  
  const scores = completed.map((p) => p.total_score || 0);
  const average_score = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
  const highest_score = scores.length > 0 ? Math.max(...scores) : 0;
  const lowest_score = scores.length > 0 ? Math.min(...scores) : 0;
  
  const completed_count = completed.length;
  const in_progress_count = participants.filter((p) => p.status === 'in_progress').length;
  const not_started_count = participants.filter((p) => p.status === 'not_started').length;
  const total_participants = participants.length;
  const completion_rate = total_participants > 0 ? (completed_count / total_participants) * 100 : 0;

  return {
    average_score: Math.round(average_score * 100) / 100,
    highest_score,
    lowest_score,
    completion_rate: Math.round(completion_rate * 100) / 100,
    completed_count,
    in_progress_count,
    not_started_count,
    total_participants,
  };
};

// Question analysis for report
export interface QuestionAnalysis {
  question_id: string;
  question_number: number;
  question_content: string;
  correct_answer: string;
  points: number;
  correct_responses: number;
  total_responses: number;
  correct_percentage: number;
  participants_count: number;
}

export const calculateQuestionAnalysis = (sessionId: string, examinerId: string): QuestionAnalysis[] => {
  const session = getTestSessionById(sessionId, examinerId);
  if (!session) return [];

  const template = getTemplateById(session.template_id, examinerId);
  if (!template) return [];

  const participants = getParticipantsBySession(sessionId, examinerId);
  const completedParticipants = participants.filter((p) => p.status === 'completed');

  // Collect all unique questions across all participants
  const allQuestionsMap = new Map<string, Question>();
  const questionToPoolSelectionMap = new Map<string, { poolId: string; pointsPerQuestion: number }>();

  completedParticipants.forEach((participant) => {
    const questions = getParticipantQuestions(participant.id, sessionId, examinerId);
    
    // Calculate points per question for each pool selection
    let questionIndex = 0;
    for (const poolSelection of template.poolSelections) {
      const pointsPerQuestion = Math.round(poolSelection.points / poolSelection.questionsToDraw);
      for (let i = 0; i < poolSelection.questionsToDraw; i++) {
        if (questionIndex < questions.length) {
          const question = questions[questionIndex];
          allQuestionsMap.set(question.id, question);
          // Store points per question (same for all questions from same pool selection)
          if (!questionToPoolSelectionMap.has(question.id)) {
            questionToPoolSelectionMap.set(question.id, {
              poolId: poolSelection.poolId,
              pointsPerQuestion,
            });
          }
          questionIndex++;
        }
      }
    }
  });

  // Convert map to array and analyze each question
  const allQuestions = Array.from(allQuestionsMap.values());
  
  return allQuestions.map((question, index) => {
    const correctAnswer = question.answers.find((a) => a.isCorrect);
    let correctCount = 0;
    let participantsWhoHadThisQuestion = 0;

    // Count only participants who actually received this question
    completedParticipants.forEach((participant) => {
      const participantQuestions = getParticipantQuestions(participant.id, sessionId, examinerId);
      const hasQuestion = participantQuestions.some((q) => q.id === question.id);
      
      if (hasQuestion) {
        participantsWhoHadThisQuestion++;
        const answers = participantAnswers.get(participant.id) || [];
        const answer = answers.find((a) => a.question_id === question.id);
        if (answer && answer.is_correct) {
          correctCount++;
        }
      }
    });

    const poolSelectionInfo = questionToPoolSelectionMap.get(question.id);
    const pointsPerQuestion = poolSelectionInfo?.pointsPerQuestion || 0;
    const correctPercentage = participantsWhoHadThisQuestion > 0 
      ? (correctCount / participantsWhoHadThisQuestion) * 100 
      : 0;

    return {
      question_id: question.id,
      question_number: index + 1,
      question_content: question.content,
      correct_answer: correctAnswer?.text || 'N/A',
      points: pointsPerQuestion,
      correct_responses: correctCount,
      total_responses: participantsWhoHadThisQuestion,
      correct_percentage: Math.round(correctPercentage * 100) / 100,
      participants_count: participantsWhoHadThisQuestion,
    };
  });
};

// Get participant details with answers
export interface ParticipantDetail {
  participant: Participant;
  answers: ParticipantAnswer[];
  questions: Question[];
}

export const getParticipantDetails = (
  sessionId: string,
  participantId: string,
  examinerId: string
): ParticipantDetail | null => {
  const session = getTestSessionById(sessionId, examinerId);
  if (!session) return null;

  const participant = mockParticipants.find(
    (p) => p.id === participantId && p.session_id === sessionId
  );
  if (!participant) return null;

  const answers = participantAnswers.get(participantId) || [];
  const questions = getParticipantQuestions(participantId, sessionId, examinerId);

  return {
    participant,
    answers,
    questions,
  };
};
</file>

</files>
