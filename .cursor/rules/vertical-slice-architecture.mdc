---
globs: backend*/**/*.ts
description: Vertical Slice Architecture guidelines for Express + TypeScript modules. Defines module structure, dependency injection patterns, repository ports, and testing strategies.
alwaysApply: false
---

This document defines the Vertical Slice Architecture pattern for backend modules in Express + TypeScript. It establishes functional programming principles, module structure conventions, dependency injection patterns, and testing strategies. All backend feature modules must follow these guidelines to ensure consistency, testability, and maintainability across the codebase.

---

# Vertical Slice Architecture Guidelines (Express + TypeScript)

## 1. General Philosophy

- **Functional over OOP**: Favor pure functions and closures over classes and `this`
- **Type Definitions**: Use `type` aliases instead of `interface` for clarity and consistency
- **Error Handling**: Use `Result<T, E>` discriminated unions for all expected failure states. Avoid throwing exceptions for domain errors
  - **Pattern**: `{ ok: true, value: T } | { ok: false, error: { type: 'ErrorType', ... } }`
- **Framework Agnostic Core**: The Domain and Application layers must never import framework-specific types like `express` or concrete database libraries

---

## 2. Module Structure

Each feature (e.g., `products`) is a self-contained vertical slice residing in its own module folder (`src/modules/{feature}`) with the following required files:

- **`domain.ts`**: Contains pure data types (Entities, Value Objects) and error unions. No external dependencies
- **`repository.ts`**: Defines the Repository Port (abstract types) and includes the concrete database or in-memory Adapters (implementations). These adapters are internal and not exported from the module root
- **`useCases.ts`**: Contains use cases implemented as functional factory functions that inject dependencies
- **`http.ts`**: The Express Adapter. Handles HTTP concerns (parsing body, setting headers) and calls the core Use Cases
- **`index.ts`**: The Composition Root. Wires the module's dependencies and exports the public API

---

## 3. Dependency & Import Rules

- **External Access**: External code (like `server.ts` or other modules) must only import from the module root (`src/modules/{feature}/index.ts`)
- **Internal Hiding**: Repository implementations and internal helper functions must remain private within the module
- **HTTP Decoupling**:
  - The `FeatureModule` type returned by the configuration function must not contain any Express types (e.g., `Router`)
  - The `createFeatureRouter` function should explicitly accept the configured `FeatureModule` as an argument
  - Importing `express`, `Request`, or `Response` is allowed only in the `http.ts` adapter

---

## 4. Configuration & Wiring

### The `configureModule` Function

Every module must export a single wiring function (e.g., `configureFeatureModule`) that acts as its dependency injection container.

### Config Object

This function must accept an optional configuration object (`FeatureModuleConfig`) to allow swapping infrastructure:

- **Infrastructure**: Allows passing connection strings or client objects (e.g., `postgresConnectionString`)
- **Stubs**: Allows overriding non-deterministic services for testing (e.g., `idGenerator?: () => string`, `now?: () => Date`)

### Internal Wiring

- Use the configuration to select the appropriate Repository implementation (Real DB vs. In-Memory)
- Instantiate Use Cases by injecting the chosen Repository and necessary services

### Return Value

The function returns an object containing all initialized use cases, which form the module's Public API. This is ready for use by the Server or Test suite. Each use case is already bound with its required dependencies.

---

## 5. Unit Testing Strategy

- **Test the Module, Not the Adapter**: Write tests against the Public API returned by `configureFeatureModule`. Avoid testing the HTTP layer for business logic
- **No Mocks (for Repositories)**: Utilize the In-Memory repository adapter for all unit/integration tests to test the true flow of the application without complex mocking frameworks
- **Determinism**: Use the configuration object to inject fixed values for IDs and Dates in tests

---

## 6. Detailed Code Examples

### 6.1. Application Layer (Use Case Implementation)

Each use case declares only the dependencies it actually needs. This minimizes coupling and makes testing easier.

```typescript
// src/modules/{feature}/useCases.ts snippet
import { err, ok, Result } from '../shared/result';
import { FeatureRepository } from './repository';
import { Resource, ResourceError } from './domain';

// Each use case declares its own minimal dependencies
type CreateResourceDeps = {
  repo: FeatureRepository;
  idGenerator: () => string;
  now: () => Date;
};

type UpdateResourceDeps = {
  repo: FeatureRepository;
  now: () => Date;
  // Note: No idGenerator needed for updates
};

type DeleteResourceDeps = {
  repo: FeatureRepository;
  // Minimal dependencies - only needs repo
};

// Command types are exported for use in tests and HTTP adapters
export type CreateResourceCommand = {
  text: string;
  // ... other fields
};

type ValidationResult = {
  valid: boolean;
  message: string;
};

// Use case with dependency injection and functional error handling
export const createResource = ({ repo, idGenerator, now }: CreateResourceDeps) => {
  return async (cmd: CreateResourceCommand): Promise<Result<Resource, ResourceError>> => {
    // 1. Validate Input
    const validation = validateResourceInput(cmd);
    if (!validation.valid) {
      return err({
        type: 'InvalidResourceData',
        message: validation.message,
      });
    }

    // 2. Construct Entity & Persist
    const timestamp = now();
    const newResource: Resource = {
      id: idGenerator(),
      text: cmd.text,
      createdAt: timestamp,
      updatedAt: timestamp,
    };

    const savedResource = await repo.save(newResource);

    // 3. Success
    return ok(savedResource);
  };
};

export const updateResource = ({ repo, now }: UpdateResourceDeps) => {
  return async (command: UpdateCommand): Promise<Result<Resource, ResourceError>> => {
    const existing = await repo.findById(command.id);
    if (!existing) {
      return err({ type: 'ResourceNotFound', resourceId: command.id });
    }
    
    const updated = { ...existing, ...command, updatedAt: now() };
    const saved = await repo.save(updated);
    return ok(saved);
  };
};

export const deleteResource = ({ repo }: DeleteResourceDeps) => {
  return async (id: string): Promise<Result<void, ResourceError>> => {
    const existing = await repo.findById(id);
    if (!existing) {
      return err({ type: 'ResourceNotFound', resourceId: id });
    }
    
    await repo.delete(id);
    return ok(undefined);
  };
};

// Validation helper functions are kept private within the module
const validateResourceInput = (input: CreateResourceCommand): ValidationResult => {
  if (!input.text || input.text.trim().length === 0) {
    return {
      valid: false,
      message: 'Resource text cannot be empty',
    };
  }
  // ... more validation rules
  return { valid: true, message: '' };
};
```

**Design Principle: Minimal Dependencies**

Each use case should declare only the dependencies it actually needs. This keeps use cases loosely coupled, easier to test, and more maintainable. For example:
- A `createResource` use case needs: `repo`, `idGenerator`, `now`
- An `updateResource` use case needs: `repo`, `now` (no ID generation)
- A `deleteResource` use case needs: `repo` only
- A `sendNotification` use case might not need the repo at all

TypeScript will enforce that you provide the correct dependencies when wiring the module.

---

### 6.2. Repository Port and In-Memory Adapter

Shows the internal contract (`FeatureRepository`) and a real, testable implementation.

```typescript
// src/modules/{feature}/repository.ts snippet
import { Resource } from './domain';

// --- Adapter: In-Memory Implementation ---
export const createInMemoryRepository = () => {
  const store = new Map<string, Resource>();

  return {
    save: async (resource: Resource) => {
      // Stores resource entity and returns it
      store.set(resource.id, resource);
      return resource;
    },

    findById: async (id: string) => {
      return store.get(id) || null;
    },

    findAll: async () => {
      return Array.from(store.values());
    },

    delete: async (id: string) => {
      return store.delete(id);
    },
  };
};

// --- Port (Internal Contract) ---
// Repository type is inferred from the implementation
export type FeatureRepository = ReturnType<typeof createInMemoryRepository>;
```

---

### 6.3. HTTP Adapter & Error Mapping

Shows how the Express layer maps the internal `Result` type to standard HTTP status codes.

```typescript
// src/modules/{feature}/http.ts snippet
import { Router, Request, Response } from 'express';
import { FeatureModule } from './index';

export const createFeatureRouter = (module: FeatureModule): Router => {
  const router = Router();

  router.post('/', async (req: Request, res: Response): Promise<void> => {
    // Assumes body validation is done here or by middleware
    const result = await module.createResource(req.body);

    if (result.ok) {
       res.status(201).json(result.value);
       return;
    }

    // Map Domain Errors to HTTP Status Codes
    switch (result.error.type) {
      case 'InvalidResourceData':
        res.status(400).json({ error: result.error.message });
        return;
      case 'ResourceNotFound':
        res.status(404).json({ error: 'Resource not found' });
        return;
      default:
        res.status(400).json({ error: 'Bad request' });
    }
  });

  router.put('/:id', async (req: Request, res: Response): Promise<void> => {
    const result = await module.updateResource({ id: req.params.id, ...req.body });

    if (result.ok) {
      res.status(200).json(result.value);
      return;
    }

    switch (result.error.type) {
      case 'ResourceNotFound':
        res.status(404).json({ error: 'Resource not found' });
        return;
      case 'InvalidResourceData':
        res.status(400).json({ error: result.error.message });
        return;
      default:
        res.status(400).json({ error: 'Bad request' });
    }
  });

  return router;
};
```

---

### 6.4. Configuration Pattern (index.ts)

Shows dependency resolution, feature switching (DB vs. Memory), and selective injection where each use case receives only the dependencies it needs.

```typescript
// src/modules/{feature}/index.ts
import { v4 as uuidv4 } from 'uuid';
import * as useCases from './useCases';
import { createInMemoryRepository } from './repository';

// Configuration accepts infrastructure settings and test stubs
export type FeatureModuleConfig = {
  // Infrastructure - connection string triggers real DB, otherwise in-memory
  postgresConnectionString?: string;
  
  // Test stubs for deterministic testing
  idGenerator?: () => string;
  now?: () => Date;
};

export const configureFeatureModule = (config: FeatureModuleConfig = {}) => {
  // 1. Repository selection is internal - defaults to in-memory
  const repo = config.postgresConnectionString
    ? (() => { throw new Error('Postgres repository not implemented yet'); })()
    : createInMemoryRepository();

  // 2. Resolve services with sensible defaults
  const idGenerator = config.idGenerator ?? uuidv4;
  const now = config.now ?? (() => new Date());

  // 3. Wire use cases - each gets exactly the dependencies it needs
  //    TypeScript ensures type safety for each use case's requirements
  return {
    createResource: useCases.createResource({ repo, idGenerator, now }),
    updateResource: useCases.updateResource({ repo, now }),
    deleteResource: useCases.deleteResource({ repo }),
    // Adding new use cases is just one line per use case
  };
};

// Export the module type for use in http.ts and tests
export type FeatureModule = ReturnType<typeof configureFeatureModule>;

// Re-export domain types for convenience
export * from './domain';
```

**Key Benefits:**
- Each use case declares only its required dependencies
- Repository selection is encapsulated within the module
- Adding new use cases requires minimal boilerplate (1-2 lines)
- Type inference keeps types synchronized automatically
- In-memory by default makes testing effortless
### 6.5. Testing the Module's Public API

Tests run against the public API of the module, NOT the HTTP layer. This makes them extremely fast, deterministic, and decoupled from Express. The in-memory repository is used automatically when no connection string is provided.

```typescript
import { describe, it, expect } from 'vitest';
import { configureFeatureModule } from '../index';
import { CreateResourceCommand } from '../useCases';

describe('Feature Module (Vertical Slice)', () => {
  it('should create a new resource successfully', async () => {
    // 1. Arrange - Wire up the module with test stubs for determinism
    const feature = configureFeatureModule({
      idGenerator: () => 'fixed-id-123',
      now: () => new Date('2023-01-01T00:00:00Z')
      // No connection string = automatic in-memory repository
    });

    // 2. Act - Call the use case directly
    const input: CreateResourceCommand = {
      text: 'Test resource',
      // ... other required fields
    };
    const result = await feature.createResource(input);

    // 3. Assert
    expect(result.ok).toBe(true);

    if (!result.ok) {
      throw new Error('Expected success result');
    }

    const resource = result.value;
    expect(resource.id).toBe('fixed-id-123');
    expect(resource.text).toBe('Test resource');
    expect(resource.createdAt).toEqual(new Date('2023-01-01T00:00:00Z'));
    expect(resource.updatedAt).toEqual(new Date('2023-01-01T00:00:00Z'));
  });

  it('should validate input data', async () => {
    // Arrange - default config uses in-memory repo
    const feature = configureFeatureModule();

    // Act - attempt invalid input
    const input: CreateResourceCommand = {
      text: '', // Invalid: empty text
      // ... other fields
    };
    const result = await feature.createResource(input);

    // Assert
    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.type).toBe('InvalidResourceData');
      expect(result.error.message).toContain('cannot be empty');
    }
  });
  
  it('should update resource successfully', async () => {
    const feature = configureFeatureModule({
      idGenerator: () => 'resource-1',
      now: () => new Date('2023-01-01T00:00:00Z')
    });
    
    // Create a resource first
    const created = await feature.createResource({ text: 'Original' });
    if (!created.ok) throw new Error('Setup failed');
    
    // Update the resource (note: updateResource doesn't need idGenerator)
    const result = await feature.updateResource({ 
      id: 'resource-1', 
      text: 'Updated text' 
    });
    
    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.value.text).toBe('Updated text');
    }
  });
});
```

**Testing Benefits:**
- No mocking frameworks needed - real in-memory repository
- Deterministic tests via injected `idGenerator` and `now`
- Fast execution (no database, no HTTP layer)
- Tests document the actual API contract
- Easy to set up and maintain