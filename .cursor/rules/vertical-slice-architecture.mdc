---
globs: backend*/**/*.ts
description: Vertical Slice Architecture guidelines for Express + TypeScript modules. Defines module structure, dependency injection patterns, repository ports, and testing strategies.
alwaysApply: false
---

This document defines the Vertical Slice Architecture pattern for backend modules in Express + TypeScript. It establishes functional programming principles, module structure conventions, dependency injection patterns, and testing strategies. All backend feature modules must follow these guidelines to ensure consistency, testability, and maintainability across the codebase.

---

# Vertical Slice Architecture Guidelines (Express + TypeScript)

## 1. General Philosophy

- **Functional over OOP**: Favor pure functions and closures over classes and `this`
- **Type Definitions**: Use `type` aliases instead of `interface` for clarity and consistency
- **Error Handling**: Use `Result<T, E>` discriminated unions for all expected failure states. Avoid throwing exceptions for domain errors
  - **Pattern**: `{ ok: true, value: T } | { ok: false, error: { type: 'ErrorType', ... } }`
- **Framework Agnostic Core**: The Domain and Application layers must never import framework-specific types like `express` or concrete database libraries

---

## 2. Module Structure

Each feature (e.g., `products`) is a self-contained vertical slice residing in its own module folder (`src/modules/{feature}`) with the following required files:

- **`domain.ts`**: Contains pure data types (Entities, Value Objects) and error unions. No external dependencies
- **`repository.ts`**: Defines the Repository Port (abstract types) and includes the concrete database or in-memory Adapters (implementations). These adapters are internal and not exported from the module root
- **`useCases.ts`**: Contains use cases implemented as functional factory functions that inject dependencies
- **`http.ts`**: The Express Adapter. Handles HTTP concerns (parsing body, setting headers) and calls the core Use Cases
- **`index.ts`**: The Composition Root. Wires the module's dependencies and exports the public API

---

## 3. Dependency & Import Rules

- **External Access**: External code (like `server.ts` or other modules) must only import from the module root (`src/modules/{feature}/index.ts`)
- **Internal Hiding**: Repository implementations and internal helper functions must remain private within the module
- **HTTP Decoupling**:
  - The `FeatureModule` type returned by the configuration function must not contain any Express types (e.g., `Router`)
  - The `createFeatureRouter` function should explicitly accept the configured `FeatureModule` as an argument
  - Importing `express`, `Request`, or `Response` is allowed only in the `http.ts` adapter

---

## 4. Configuration & Wiring

### The `configureModule` Function

Every module must export a single wiring function (e.g., `configureFeatureModule`) that acts as its dependency injection container.

### Config Object

This function must accept an optional configuration object (`FeatureModuleConfig`) to allow swapping infrastructure:

- **Infrastructure**: Allows passing connection strings or client objects (e.g., `postgresConnectionString`)
- **Stubs**: Allows overriding non-deterministic services for testing (e.g., `idGenerator?: () => string`, `now?: () => Date`)

### Internal Wiring

- Use the configuration to select the appropriate Repository implementation (Real DB vs. In-Memory)
- Instantiate Use Cases by injecting the chosen Repository and necessary services

### Return Value

The function returns an object containing all initialized use cases, which form the module's Public API. This is ready for use by the Server or Test suite. Each use case is already bound with its required dependencies.

---

## 5. Unit Testing Strategy

- **Test the Module, Not the Adapter**: Write tests against the Public API returned by `configureFeatureModule`. Avoid testing the HTTP layer for business logic
- **No Mocks (for Repositories)**: Utilize the In-Memory repository adapter for all unit/integration tests to test the true flow of the application without complex mocking frameworks
- **Determinism**: Use the configuration object to inject fixed values for IDs and Dates in tests

---

## 6. Detailed Code Examples

### 6.1. Application Layer (Use Case Implementation)

Each use case declares only the dependencies it actually needs. This minimizes coupling and makes testing easier.

```typescript
// src/modules/{feature}/useCases.ts snippet
import { ok, err, Result } from '../../shared/types';
import { FeatureRepository } from './repository';
import { Resource, ResourceError, ResourceCommand } from './domain';

// Each use case declares its own minimal dependencies
type CreateResourceDeps = {
  repo: FeatureRepository;
  idGenerator: () => string;
  now: () => Date;
};

type UpdateResourceDeps = {
  repo: FeatureRepository;
  now: () => Date;
  // Note: No idGenerator needed for updates
};

type DeleteResourceDeps = {
  repo: FeatureRepository;
  // Minimal dependencies - only needs repo
};

// Use case with dependency injection and functional error handling
export const createResource = ({ repo, idGenerator, now }: CreateResourceDeps) => {
  return async (command: ResourceCommand): Promise<Result<Resource, ResourceError>> => {
    // 1. Check Constraints
    const existing = await repo.findByUniqueId(command.uniqueKey);
    if (existing) {
      return err({ type: 'ResourceConflict', key: command.uniqueKey });
    }

    // 2. Construct Entity & Persist
    const newResource: Resource = { 
      id: idGenerator(), 
      ...command,
      createdAt: now()
    };
    await repo.save(newResource);

    // 3. Success
    return ok(newResource);
  };
};

export const updateResource = ({ repo, now }: UpdateResourceDeps) => {
  return async (command: UpdateCommand): Promise<Result<Resource, ResourceError>> => {
    const existing = await repo.findById(command.id);
    if (!existing) {
      return err({ type: 'NotFound', id: command.id });
    }
    
    const updated = { ...existing, ...command, updatedAt: now() };
    await repo.save(updated);
    return ok(updated);
  };
};

export const deleteResource = ({ repo }: DeleteResourceDeps) => {
  return async (id: string): Promise<Result<void, ResourceError>> => {
    const existing = await repo.findById(id);
    if (!existing) {
      return err({ type: 'NotFound', id });
    }
    
    await repo.delete(id);
    return ok(undefined);
  };
};
```

**Design Principle: Minimal Dependencies**

Each use case should declare only the dependencies it actually needs. This keeps use cases loosely coupled, easier to test, and more maintainable. For example:
- A `createResource` use case needs: `repo`, `idGenerator`, `now`
- An `updateResource` use case needs: `repo`, `now` (no ID generation)
- A `deleteResource` use case needs: `repo` only
- A `sendNotification` use case might not need the repo at all

TypeScript will enforce that you provide the correct dependencies when wiring the module.

---

### 6.2. Repository Port and In-Memory Adapter

Shows the internal contract (`FeatureRepository`) and a real, testable implementation.

```typescript
// src/modules/{feature}/repository.ts snippet
import { Resource } from './domain';

// --- Port (Internal Contract) ---
export type FeatureRepository = {
  save: (resource: Resource) => Promise<void>;
  findByUniqueId: (key: string) => Promise<Resource | null>;
};

// --- Adapter: In-Memory Implementation ---
export const createInMemoryRepository = (): FeatureRepository => {
  const store = new Map<string, Resource>();

  return {
    save: async (resource) => {
      // Stores resource entity
      store.set(resource.id, resource);
    },
    findByUniqueId: async (key) => {
      // Logic to find by key within the store
      for (const resource of store.values()) {
        if (resource.uniqueKey === key) return resource;
      }
      return null;
    },
  };
};
```

---

### 6.3. HTTP Adapter & Error Mapping

Shows how the Express layer maps the internal `Result` type to standard HTTP status codes.

```typescript
// src/modules/{feature}/http.ts snippet
import { Router, Request, Response } from 'express';
import { FeatureModule } from './index';

export const createFeatureRouter = (module: FeatureModule): Router => {
  const router = Router();

  router.post('/', async (req: Request, res: Response): Promise<void> => {
    // Assumes body validation is done here or by middleware
    const result = await module.createResource(req.body);

    if (result.ok) {
       res.status(201).json(result.value);
       return;
    }

    // Map Domain Errors to HTTP Status Codes
    switch (result.error.type) {
      case 'ResourceConflict':
        res.status(409).json({ error: 'Resource already exists' });
        return;
      case 'InvalidParameter':
        res.status(400).json({ error: 'Input parameter is invalid' });
        return;
    }
  });

  router.put('/:id', async (req: Request, res: Response): Promise<void> => {
    const result = await module.updateResource({ id: req.params.id, ...req.body });

    if (result.ok) {
      res.status(200).json(result.value);
      return;
    }

    switch (result.error.type) {
      case 'NotFound':
        res.status(404).json({ error: 'Resource not found' });
        return;
      default:
        res.status(400).json({ error: 'Bad request' });
    }
  });

  return router;
};
```

---

### 6.4. Configuration Pattern (index.ts)

Shows dependency resolution, feature switching (DB vs. Memory), and selective injection where each use case receives only the dependencies it needs.

```typescript
// src/modules/{feature}/index.ts
import { v4 as uuidv4 } from 'uuid';
import * as useCases from './useCases';
import { createInMemoryRepository, createPostgresRepository } from './repository';

// Configuration accepts infrastructure settings and test stubs
export type FeatureModuleConfig = {
  // Infrastructure - connection string triggers real DB, otherwise in-memory
  postgresConnectionString?: string;
  
  // Test stubs for deterministic testing
  idGenerator?: () => string;
  now?: () => Date;
};

export const configureFeatureModule = (config: FeatureModuleConfig = {}) => {
  // 1. Repository selection is internal - defaults to in-memory
  const repo = config.postgresConnectionString 
    ? createPostgresRepository(config.postgresConnectionString)
    : createInMemoryRepository();

  // 2. Resolve services with sensible defaults
  const idGenerator = config.idGenerator ?? uuidv4;
  const now = config.now ?? (() => new Date());

  // 3. Wire use cases - each gets exactly the dependencies it needs
  //    TypeScript ensures type safety for each use case's requirements
  return {
    createResource: useCases.createResource({ repo, idGenerator, now }),
    updateResource: useCases.updateResource({ repo, now }),
    deleteResource: useCases.deleteResource({ repo }),
    // Adding new use cases is just one line per use case
  };
};

// Export the module type for use in http.ts and tests
export type FeatureModule = ReturnType<typeof configureFeatureModule>;
```

**Key Benefits:**
- Each use case declares only its required dependencies
- Repository selection is encapsulated within the module
- Adding new use cases requires minimal boilerplate (1-2 lines)
- Type inference keeps types synchronized automatically
- In-memory by default makes testing effortless
### 6.5. Testing the Module's Public API

Tests run against the public API of the module, NOT the HTTP layer. This makes them extremely fast, deterministic, and decoupled from Express. The in-memory repository is used automatically when no connection string is provided.

```typescript
import { configureUsersModule } from './index';

describe('Users Module (Vertical Slice)', () => {
  it('should register a new user successfully', async () => {
    // 1. Arrange - Wire up the module with test stubs for determinism
    const users = configureUsersModule({
      idGenerator: () => 'fixed-id-123',
      now: () => new Date('2023-01-01T00:00:00Z')
      // No connection string = automatic in-memory repository
    });

    // 2. Act - Call the use case directly
    const result = await users.registerUser({ email: 'test@example.com' });

    // 3. Assert
    if (!result.ok) throw new Error('Expected success');
    
    expect(result.value).toEqual({
      id: 'fixed-id-123',
      email: 'test@example.com',
      createdAt: new Date('2023-01-01T00:00:00Z')
    });
  });

  it('should prevent duplicate emails', async () => {
    // Arrange - default config uses in-memory repo
    const users = configureUsersModule();

    // Act - attempt duplicate registration
    await users.registerUser({ email: 'alice@example.com' });
    const result = await users.registerUser({ email: 'alice@example.com' });

    // Assert
    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error).toEqual({ 
        type: 'EmailAlreadyTaken', 
        email: 'alice@example.com' 
      });
    }
  });
  
  it('should validate email format', async () => {
    const users = configureUsersModule();
    
    const result = await users.registerUser({ email: 'not-an-email' });
    
    expect(result.ok).toBe(false);
    if (!result.ok) {
      expect(result.error.type).toBe('InvalidEmail');
    }
  });
  
  it('should update user profile', async () => {
    const users = configureUsersModule({
      idGenerator: () => 'user-1',
      now: () => new Date('2023-01-01T00:00:00Z')
    });
    
    // Create a user first
    const created = await users.registerUser({ email: 'bob@example.com' });
    if (!created.ok) throw new Error('Setup failed');
    
    // Update the user (note: updateUser doesn't need idGenerator)
    const result = await users.updateUser({ 
      id: 'user-1', 
      displayName: 'Bob Smith' 
    });
    
    expect(result.ok).toBe(true);
    if (result.ok) {
      expect(result.value.displayName).toBe('Bob Smith');
    }
  });
});
```

**Testing Benefits:**
- No mocking frameworks needed - real in-memory repository
- Deterministic tests via injected `idGenerator` and `now`
- Fast execution (no database, no HTTP layer)
- Tests document the actual API contract
- Easy to set up and maintain